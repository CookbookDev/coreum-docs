## Go code skeleton

### Imports and main function

Create standard `main.go` file containing this skeleton importing `pkg/client`:

```go
package main

import (
	"github.com/CoreumFoundation/coreum/v3/pkg/client"
    coreumconfig "github.com/CoreumFoundation/coreum/v3/pkg/config"
	"github.com/CoreumFoundation/coreum/v3/pkg/config/constant"
)

const (
	senderMnemonic = "" // put mnemonic here

	chainID          = constant.ChainIDTest
	addressPrefix    = constant.AddressPrefixTest
	denom            = constant.DenomTest
	recipientAddress = "testcore1534s8rz2e36lwycr6gkm9vpfe5yf67wkuca7zs"
	nodeAddress      = "full-node.testnet-1.coreum.dev:9090"
)

func main() {

}
```

### Preparing test account

Before you may broadcast transactions, you need to have access to a funded account. Normally you
would create a private key stored securely in local keystore. Here, for simplicity, we will use
private key generated by our faucet. Never ever use mnemonic directly in code and never ever use key
generated by faucet in production. It might cause complete funds loss! Please reference keyring
documentation to learn on using keyring: https://docs.cosmos.network/v0.47/user/run-node/keyring and
https://pkg.go.dev/github.com/cosmos/cosmos-sdk/crypto/keyring.

To get funded account, go to our faucet website: https://docs.coreum.dev/tools-ecosystem/faucet and
click on "Generate Funded Wallet" button in "Testnet" section.

In response, you get your wallet address on our testnet chain and mnemonic used to generate the
private key. Assign mnemonic to the constant `senderMnemonic` in the code snippet above.

### Setting Cosmos SDK configuration

First we need to configure Cosmos SDK:

```go
config := sdk.GetConfig()
config.SetBech32PrefixForAccount(addressPrefix, addressPrefix+"pub")
config.SetCoinType(constant.CoinType)
config.Seal()
```

### Preparing client context and tx factory

Before we are able to broadcast transaction, we must create and configure client context and tx
factory:

```go
modules := module.NewBasicManager(
    auth.AppModuleBasic{},
)

// If you don't use TLS then replace `grpc.WithTransportCredentials(credentials.NewTLS(&tls.Config{MinVersion: tls.VersionTLS12}))` with `grpc.WithInsecure()`
grpcClient, err := grpc.Dial(nodeAddress, grpc.WithTransportCredentials(credentials.NewTLS(&tls.Config{MinVersion: tls.VersionTLS12})))
if err != nil {
    panic(err)
}

encodingConfig := coreumconfig.NewEncodingConfig(modules)

clientCtx := client.NewContext(client.DefaultContextConfig(), modules).
    WithChainID(string(chainID)).
    WithGRPCClient(grpcClient).
    WithKeyring(keyring.NewInMemory(encodingConfig.Codec)).
	WithBroadcastMode(flags.BroadcastSync)

txFactory := client.Factory{}.
    WithKeybase(clientCtx.Keyring()).
    WithChainID(clientCtx.ChainID()).
    WithTxConfig(clientCtx.TxConfig()).
    WithSimulateAndExecute(true)
```

### Generate private key

To sign a transaction, private key generated from mnemonic stored in `senderMnemonic` is required.
We store that key in the temporary keystore. In production you should use any keyring other than
`memory` or `test`. Good choice might be `os` or `file`. For more details, refer keyring
documentation: https://docs.cosmos.network/v0.47/user/run-node/keyring and
https://pkg.go.dev/github.com/cosmos/cosmos-sdk/crypto/keyring.

```go
senderInfo, err := clientCtx.Keyring().NewAccount(
    "key-name",
    senderMnemonic,
    "",
    sdk.GetConfig().GetFullBIP44Path(),
    hd.Secp256k1,
)
if err != nil {
    panic(err)
}
```
